# 03. 工具实现细节（目标态）

## 1. 工具注册与分发
- 统一接口：`tools.Tool`
- 可选审批接口：`tools.ApprovalAware`
- 注册器：`tools.Registry`
  - `DefinitionsFiltered(allowed)`：按 agent 开关暴露工具。
  - `ApprovalRequest(name,args)`：统一拉取工具级审批请求。
  - `Execute(name,args)`：按名执行。

## 2. 内置工具清单
- 文件类：`read` `write` `list` `glob` `grep` `patch`
- 执行类：`bash`
- 任务管理：`todoread` `todowrite`
- 扩展能力：`skill` `task`
- LSP类：`lsp_diagnostics` `lsp_definition` `lsp_hover`

说明：目标态不包含 `mcp_proxy`。

## 9. LSP 工具
### 9.1 架构设计
- **LSP Client**: `internal/lsp/client.go`，负责 JSON-RPC 通信
- **LSP Manager**: `internal/lsp/manager.go`，管理多语言 Server 生命周期
- **工具实现**: `internal/tools/lsp_*.go`，封装为 Coder 工具

### 9.2 默认配置
- **sh**: `bash-language-server start`
- **py**: `pylsp`

### 9.3 工具详情

#### `lsp_diagnostics`
- 输入：`path`
- 输出：`{ok, diagnostics[], count, server_status}`
- 行为：
  - 识别文件语言（根据扩展名）
  - 连接对应 LSP Server 获取诊断信息
  - Server 未安装时返回 `ok=false`，附带安装提示
- 降级策略：返回友好错误，建议用 `grep` 查找潜在问题

#### `lsp_definition`
- 输入：`path`, `line` (0-based), `character` (0-based)
- 输出：`{ok, location{uri, range{start{line,character},end{line,character}}}, server_status}`
- 行为：获取符号定义位置
- 降级策略：返回友好错误，建议用 `grep` 搜索符号

#### `lsp_hover`
- 输入：`path`, `line`, `character`
- 输出：`{ok, contents, server_status}`
- 行为：获取符号类型和文档信息
- 降级策略：返回友好错误，建议阅读源码

### 9.4 Server 检测与提示
- 启动时检测已配置语言的 LSP Server 是否可执行
- 未安装时打印一次安装提示（不阻塞启动）
- 格式：`[LSP] <语言>: <server> 未安装，运行: <安装命令>`

### 9.5 权限策略
- LSP 工具默认权限：`allow`（只读操作）

## 3. 文件类工具
### `read`
- 输入：`path,offset?,limit?`
- 输出：`{ok,path,content,start_line,end_line,has_more}`
- 行为：
  - 按行级分页读取文件内容：从 `offset` 指定的行号开始，最多返回 `limit` 行文本。
  - 当未提供 `offset` 或 `offset<=0` 时，归一化为从第 1 行开始；当未提供 `limit` 或 `limit<=0` 时，归一化为默认值 `50`，并在实现中对过大 `limit` 进行上限裁剪（例如 200 行）。
  - 当 `offset` 大于文件总行数时，视为 EOF，返回 `ok=true` 且 `content=""`，`has_more=false`。
- 字段含义：
  - `start_line` / `end_line`：当前分块内容在文件中的起止行号（1 基，若无内容则可为 0 或省略）。
  - `has_more`：布尔值，表示在当前分块之后文件是否仍有更多内容可读。
- 关键约束：路径必须在 workspace 内。

### `write`
- 输入：`path,content`
- 输出：`{ok,path,operation,size,additions,deletions,diff}`
- 行为：全量覆盖写入；返回简化 unified diff。

### `list`
- 输入：`path`（可空）
- 输出：`{ok,path,items[]}`
- 条目字段：`name/path/is_dir/size_bytes`。

### `glob`
- 输入：`pattern`
- 输出：`{ok,matches[]}`
- 关键约束：拒绝绝对路径 pattern。

### `grep`
- 输入：`pattern,path,max_matches`
- 输出：`{ok,count,matches[]}`
- 默认 `max_matches=200`；跳过二进制文件。

### `patch`
- 输入：`patch,dry_run`
- 输出：`{ok,applied,results[]}`
- 行为：按 unified diff 逐文件、逐 hunk 应用。
- 约束：
  - 不允许硬编码调试日志输出到固定路径。
  - 返回结果需包含每个受影响文件的路径与操作类型，供 Orchestrator 构建回合级回滚快照。

## 4. `bash` 工具
- 执行器：`/bin/sh -lc <command>`
- 工作目录：workspace root
- 超时：`context.WithTimeout`
- 输出截断：按 `output_limit_bytes` 限制 stdout/stderr

输出结构：
- `ok`
- `command`
- `exit_code`
- `stdout`
- `stderr`
- `truncated`
- `duration_ms`

## 5. `todoread` / `todowrite`

- `todoread`：读取当前 session 的 todo 列表。
  - 用途：
    - 在已经存在 todo 列表的复杂任务中，周期性同步当前状态；
    - 在切回历史会话或用户询问“之前做到哪一步”时恢复上下文。
  - 输入：无参数（`{}`）。
  - 输出（示意）：`{ok, session_id, items[], count, in_progress}`。
  - 推荐使用时机：
    - 仅当本会话**已经有 todo** 时高频调用；
    - 对于单一、简单任务的新会话，**不要**在首轮就调用 `todoread`。

- `todowrite`：整表替换当前 session 的 todo 列表。
  - 输入：`{ todos: TodoItem[] }`，其中：
    - `TodoItem` 至少包含 `id, content, status, priority`；
    - `status ∈ {pending, in_progress, completed}`；
    - `priority ∈ {high, medium, low}`。
  - 约束：
    - `in_progress` 最多 1 条，否则返回参数错误；
    - 调用方应始终传入**完整列表**，而非只传增量。
  - 推荐调用策略：
    - 当本会话还没有 todo 且任务明显是多步骤/复杂需求时，可以先根据用户输入构建 todo，再调用 `todowrite` 初始化；
    - 当存在 todo 且某一步实际完成或推进后，先用 `todoread` 读出列表，在模型推理中更新状态，再通过 `todowrite` 写回；
    - 对一次性、简单小任务，默认不创建 todo，避免无意义噪音。

## 6. `skill` 工具
- `action=list`：返回可见 skill 列表。
- `action=load`：返回 `SKILL.md` 内容。
- 审批策略：
  - 显式调用走策略审批链。
  - 自动触发路径可免审批（但仍受 `deny` 约束）。

## 7. `task` 工具
- 输入：`agent,objective`
- 执行：调用子代理 runner。
- 输出契约（目标态）：
  - `ok`
  - `agent`
  - `summary`

说明：`task` 返回契约采用 summary 文本，不使用结构化 `status/artifacts/...` 契约。

## 8. 错误处理约定
- 未知工具：返回 `unknown tool`。
- 参数非法：返回可读 `args` 错误。
- 路径越界：返回权限错误。
- patch 不匹配：返回上下文不匹配错误。
- bash 超时：`exit_code=124`，`ok=false`。
