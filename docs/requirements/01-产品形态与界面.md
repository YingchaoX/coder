# 01. 产品形态与界面

## 1. 启动形态
用户通过命令直接启动二进制。

配置文件发现顺序：
1. 当前路径：`./.coder/config.json`
2. 家目录：`~/.coder/config.json`（仅在当前路径不存在时回退）
3. 若两者都不存在，使用内置默认配置

启动后进入**终端 REPL**，无全屏 TUI。
- **凡出现用户输入提示符**（即等待用户输入时），**必须**展示当前 context 的 **tokens 数**与当前 model；不可省略。cwd 仅在第二行提示符中展示，第一行不重复。
- **提示区排版**：**第一行**展示 context（tokens 数）与 model；**第二行**展示提示符（含当前模式与 cwd，如 `[default] /path/to/cwd> `）及用户输入区。即：信息一行，用户输入框（提示符 + 输入）在下一行。
- 示例：
  - 第一行：`context: 1200 tokens · model: gpt-4o`
  - 第二行：`[default] /Users/dev/myapp> `（或后接用户已输入内容）
- Todos 在**对话流中**随回合展示；Tools、Skills 通过输入 `/tools`、`/skills` **按需查看**。

## 2. 用户可见交互
- **发送**：**TTY 下 Enter 即发送当前输入**；多行仅支持“粘贴多行后展示 `[copy N lines]`，再按 Enter 一次性发送”；Ctrl+D 不再作为发送键，仅作为 EOF/终端行为。非 TTY（管道）下按行或 EOF 读取，详见技术文档。
- **输入历史（↑/↓）**：与 Linux 终端行为一致。在输入态下，**↑** 可调出上一条用户输入，**↓** 可调出下一条用户输入，用于在当前会话中前后翻阅历史输入 prompt，不提交即不发送。
- **模式切换**：通过内建命令（如 `/mode plan` 或 `/plan`、`/default`、`/auto-edit`、`/yolo`），切换后提示符立即体现当前模式。
- **流式中断**：仅保证 **Ctrl+C** 中断流式输出；不保证 Esc 行为。
- **Ctrl+C**：退出程序。

### 2.1 命令模式（`!`）
- **触发方式**：在提示符所在行**行首输入 `!`**，后跟任意 shell 命令（例如 `! ls`、`! go test ./...`），本次输入整体作为“命令模式回合”处理。
- **输出形态**：命令执行结果以单独区块展示，头部统一为 **`[COMMAND] ───`**，正文包含：
  - 原始命令回显：`$ <command>`
  - 基本状态：`exit=<code> duration=<xx>ms`（若底层输出被字节截断，则附 ` (truncated)` 标记）
  - 标准输出段：`stdout:` 后接命令 stdout（仅展示前若干行）
  - 标准错误段（如有）：`stderr:` 后接命令 stderr（仅展示前若干行）
- **展示截断**：为避免刷屏，命令输出按**行数做二次截断**：
  - stdout/stderr 各自仅展示前 **N 行（默认约 20 行）**；
  - 若存在被行级截断的部分，在对应段末尾追加一行 `...[output truncated for display]` 或 `...[error output truncated for display]` 提示；
  - 底层工具仍按 `output_limit_bytes` 做字节级截断，并在 JSON 结果中标记 `truncated`，不受本行级截断影响。
- **上下文影响**：命令模式不会调用大模型，但其输入（例如 `! ls`）与格式化后的命令输出整体，都会作为一对 `user`/`assistant` 消息写入对话历史，**在下一次调用大模型时一并进入上下文**，可作为后续回答的依据。
- **context 行刷新**：每次命令模式执行结束后，必须重新计算并通过现有回调链路刷新一次 `context: <tokens> · model: <name>` 行，让用户能立刻感知命令输出对上下文长度的影响。

## 3. 输出呈现
- 助手文本支持流式追加显示。
- 模型 `thinking` 结果在输出流内直接全文展示，不提供折叠。
- 工具开始时会记录工具名与简洁摘要。
- 工具完成时展示结构化摘要；若有详细输出（如 write 的 diff），在同一输出流内直接展示，不提供折叠/展开。
- `write`/`patch` 返回 diff 时，以 **unified diff 文本**（单列 `+`/`-`/`@@`）在输出流内展示，不做左右并排视图；diff 在工具完成时**直接**展示，无需额外操作。

## 4. 输出流行为
- 按时间顺序在终端输出：用户消息、助手结果、工具摘要、日志文本。
- 历史通过**终端滚动**回看。
- `write`/`patch` 返回 diff 时，以 unified 形式在同一输出流内展示，工具完成即展示，无折叠。
- 文件访问轨迹作为消息内容的一部分展示。

## 5. 用户侧预期
- 这是一个“对话驱动 + 工具执行”的终端代理，而不是 IDE。
- 不需要 VSCode 插件；核心工作流在终端内完成。
- 当前主交互入口是自然语言输入、`!` 特殊命令（shell）和 `/` 内建命令：`/help`、`/model`、`/permissions`、`/mode`（或 `/plan`、`/default`、`/auto-edit`、`/yolo`）、`/tools`、`/skills`、`/todos`、`/new`、`/resume`、`/compact`、`/diff`、`/undo`。

## 6. 模式边界（用户可感知）
- `plan`：以任务拆解、方案设计、风险分析为主；默认不执行写入类工具（`write`/`patch`）与副作用命令。
- `default`：均衡模式；允许读取、分析、少量执行，涉及写入/高风险操作时按权限策略处理。
- `auto-edit`：以改动交付为主；在需求明确时可主动调用读写工具并触发自动验证与修复重试。
- `yolo`：高自治执行模式；高风险 `bash` 也默认放行执行（不再拦截 `ask` / `deny` / 硬阻断结果）。
- 四种模式都遵守工作区文件路径边界；仅 `yolo` 的 `bash` 路径例外放宽风控拦截。

## 7. 视觉与实现约束（极简）
- 使用**终端默认样式**（等宽字体、无额外主题或字体配置）。
- 界面极简：少颜色、少装饰。

## 8. 输出与界面颜色约定
以下类别在终端输出中需使用约定颜色（实现时可采用 ANSI 色或终端 256 色对应）：

| 类别 | 颜色 | 说明 |
|------|------|------|
| **context 行**（第一行 tokens · model） | 灰色 / dim | 与正文区分，弱化辅助信息 |
| **提示符**（`[mode] /path> `） | 绿色 / green | 标识输入位置，与 Linux 常见提示符一致 |
| **用户输入**（用户键入的整行内容） | 默认前景色 | 与助手回复同层级 |
| **助手正文**（助手回复、总结） | 默认前景色 | 正文主色；**[ANSWER]** 块不显示左侧竖线，仅保留 `[ANSWER]` 标题与正文 |
| **thinking**（模型思考过程） | 灰色 / dim，可选斜体 | 与正文区分，表示“中间过程” |
| **工具名/工具事件**（如 `[tool] read`、`[bash]`） | 蓝色 / blue | 标识工具调用 |
| **工具成功**（如 `[tool] read ok`） | 绿色 / green | 表示成功 |
| **工具失败/错误**（如 `[tool] bash · exit_code=1`、错误信息） | 红色 / red | 表示失败或需关注 |
| **diff 新增行**（unified diff 的 `+` 行） | 绿色 / green | 与通用 diff 习惯一致 |
| **diff 删除行**（unified diff 的 `-` 行） | 红色 / red | 与通用 diff 习惯一致 |
| **diff 元信息**（`---`、`+++`、`@@` 等） | 灰色 / dim | 弱化元信息 |
| **系统/审批/自动验证等提示**（如 `[approval]`、`[auto-verify]`、todos 摘要表头） | 黄色 / yellow | 标识系统级或需确认信息；todos 列表项按状态分色见下 |
| **Todos 列表项** | 按状态 | **已完成 (done)** = 青/浅蓝 (cyan)；**进行中 (in_progress)** = 黄或橙 (yellow/orange)；**待办 (pending)** = 灰 (dim/gray)，与设计稿/截图一致 |
| **错误与异常**（未知命令、会话不存在、step limit 等） | 红色 / red | 明确错误态 |

- 未列出的输出（如文件列表、命令 stdout 原文）使用**默认前景色**。
- 若终端不支持多色，至少区分：正文（默认）、错误/失败（红或高亮）、提示符（绿或高亮）。
