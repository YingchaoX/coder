# 02. 交互逻辑与状态流

## 1. 单回合主流程
1. 用户输入文本。
2. 系统先判断是否为特殊命令：`!` 或 `/` 前缀。
3. 若为 `!`，进入 shell 命令分支；若为 `/`，进入内建命令分支。
4. 若不是特殊命令，进入模型-工具循环。
5. 模型若返回工具调用，则执行权限检查与工具执行。
6. 没有工具调用时，输出最终答案并结束回合。

## 2. 普通对话模式（非 `!` / `/`）
触发条件：输入不以 `!`、`/` 开头。

关键行为：
- 首先把用户消息追加到会话内存。
- 历史通过**终端滚动**回看。
- 输入模式为 `plan`、`default`、`auto-edit`、`yolo`，通过内建命令（如 `/mode` 或 `/plan`、`/default`、`/auto-edit`、`/yolo`）切换：
  - `plan`：以分析、拆解与方案输出为主；默认不走写入链路。
  - `default`：均衡模式；可读可分析，写入行为按用户意图与权限策略触发。
  - `auto-edit`：以改动交付为主；在需求明确时可主动执行写入、验证与修复重试。
  - `yolo`：高自治编辑模式；在 `auto-edit` 基础上对 `bash` 执行默认全放行（含高风险命令）。
- 在每一步模型调用前可能触发上下文压缩。
- 若任务被判定为复杂任务且开启 `require_todo_for_complex`，会自动初始化 todo（仅在当前会话无未完成 todo 时）。
- 模型可连续多步调用工具，直到不再返回 tool calls 或达到步数上限。
- 四种模式共享工作区路径约束；`yolo` 下 `bash` 不再受 `ask`/`deny`/危险命令硬阻断拦截。
- **提示符前**默认展示 context（**tokens 数**）与 model（第一行），提示符（含 cwd）与输入在第二行；**对话流中**展示 todos；Tools、Skills 通过 `/tools`、`/skills` 按需查看。

## 3. 命令模式（`!`）
触发条件：输入以 `!` 开头。

行为：
- 跳过模型规划，直接走 `bash` 工具执行路径。
- 视为用户直接在终端执行 shell 命令：不经过权限策略与审批链（包括危险命令风险审批），仅受工作区路径等基础安全约束。
- 执行结果会以固定结构写回会话文本，包含命令、退出码、stdout/stderr。

## 4. 命令模式（`/`）
触发条件：输入以 `/` 开头。

行为：
- 跳过模型规划，直接进入内建命令分发。
- 首发命令集合：`/help`、`/model`、`/permissions`、`/mode`（或 `/plan`、`/default`、`/auto-edit`、`/yolo`）、`/tools`、`/skills`、`/todos`、`/new`、`/resume`、`/compact`、`/diff`、`/undo`。
- 内建命令执行结果以文本回写会话；未知命令返回错误提示。

子命令契约：
- `/help`：展示命令、Enter/Ctrl+D 输入规则、流式中断等说明。
- `/model <name>`：立即切换当前会话模型，并尝试持久化到 `./.coder/config.json`。
- `/permissions [preset]`：无参数时展示当前权限矩阵；有参数时切换权限预设（`strict`、`balanced`、`auto-edit`、`yolo`）。
- `/mode <name>`：切换当前模式并更新提示符（或使用 `/plan`、`/default`、`/auto-edit`、`/yolo` 等价形式）。
- `/tools`：展示当前可用工具列表/摘要。
- `/skills`：展示当前可用技能列表/摘要。
- `/todos`：仅查看当前会话 todo 列表（只读）。
- `/new`：创建新会话并切到空上下文输入态。
- `/resume <session-id>`：按会话 ID 恢复历史会话；若目标不存在，返回可读错误。
- `/compact`：强制执行一次上下文压缩并回显摘要。
- `/diff`：展示当前工作区改动差异摘要；可展开查看详细 diff。
- `/undo`：撤销“上一次用户输入对应整回合”产生的文件改动（包含该回合内所有助手写入与补丁，以及该回合新增文件的回收），仅在检测到 git 可用且当前目录是 git 仓库时允许。

会话边界：
- 当前版本仅支持线性会话，不支持 `/fork`。

## 5. 工具执行分支
每个工具调用都会经历：
1. Agent 工具开关检查（工具是否被当前 agent 禁用）。
2. Policy 决策（`allow`/`ask`/`deny`）。
3. 工具自身审批检查（如 bash 危险命令分析）。
4. 执行工具并写入 `tool` 消息。

例外：
- 当前模式为 `yolo` 且工具为 `bash` 时，跳过第 2/3 步，直接执行。

技能触发规则：
- 允许基于语义自动触发 skill（无需用户显式输入技能名）。
- skill 的自动触发路径为免审批执行（即遇 `ask` 时不阻塞 REPL 等待审批）。
- 若技能不存在或加载失败，必须回退到无技能路径并给出可读提示。

审批（ask）时的行为：需要审批时，在 stdout 打印待执行命令与说明，从 REPL 读一行（y/n/always）后继续；非交互模式（`auto_approve_ask=true` 或 `approval.interactive=false`）下不阻塞、自动放行。

工具事件展示规则：
- 默认显示简洁摘要（工具名、关键参数、核心结果、耗时）。
- 完整输出（如 write 的 diff、工具返回的详情）在同一输出流内直接展示，无需展开操作。
- `thinking` 输出在输出流内直接全文展示，不提供折叠。

## 6. 自动验证循环
触发条件同时满足：
- 本回合执行过 `write` 或 `patch`。
- 编辑目标不全是文档文件（例如 `.md`、`docs/`）。
- `workflow.auto_verify_after_edit=true`。
- `bash` 工具可用且允许。
- 验证尝试次数未超过 `max_verify_attempts`。
- 当前模式为 `auto-edit` 或 `yolo`；`default` 模式下仅在用户明确要求“执行验证”时触发；`plan` 模式不触发。

行为：
- 自动验证仅允许“最小无副作用检查”白名单命令（固定集合）：
  - `go test ./...`
  - `pytest -q`
  - `npm test -- --watch=false`
  - `pnpm test -- --watch=false`
  - `yarn test --watch=false`
  - `cargo test`
  - `mvn -q test`
  - `gradle test`
  - `./gradlew test`
- 自动选取命令优先级（高到低）：
  1. 用户显式指定且命中白名单的命令。
  2. 项目配置 `workflow.verify_commands` 中首个命中白名单的命令。
  3. 按项目类型推断并映射到白名单中的命令。
- 若候选命令不在白名单内，视为不可执行，不得降级执行其它非白名单命令。
- 若未找到可执行的白名单命令，允许跳过自动验证，但必须显式提示“未执行自动验证”。
- 失败且可重试时，系统向模型注入“请修复并再次验证”的提示继续循环；默认最多自动重试 2 次，可由 `max_verify_attempts` 收紧。
- 失败且不可重试（环境问题）时，给出“best-effort”警告并结束自动验证。

## 7. 复杂任务判定条件
输入先做 `trim`，再按 Unicode 字符计数。满足任一条件即判定为复杂任务：
- 文本长度 `>= 40`。
- 命中多步骤关键词数 `>= 3`（例如：并且、同时、另外、分别、步骤、重构、迁移、优化）。
- 按分隔符 `，。；、,\n` 切分后，有效片段数 `>= 3`。
- 出现显式多目标枚举（如 `1. 2. 3.`、`A/B/C`）。

判定优先级：
1. 先判断显式多目标枚举，命中即复杂任务。
2. 再判断长度阈值 `>= 40`。
3. 再判断关键词与分段阈值（均使用 `>= 3`）。

## 8. 回合终止条件
- 模型返回无工具调用的文本答案。
- 达到步数上限。
- Provider 调用失败并不可恢复。

## 9. `/model` 持久化与继承
- `/model <name>` 在执行成功后立即生效（当前会话）。
- 同步尝试写入 `./.coder/config.json`；写入成功后，后续会话默认继承。
- 若写入失败，不回滚当前会话模型；仅提示持久化失败。

## 10. 会话记录与 OpenAI 兼容格式
- 每个会话都需要有一个 JSON 快照文件：`.coder/sessions/<session_id>.json`，用于离线审阅与调试。
- JSON 中的 `messages` 字段必须使用 OpenAI Chat Completions 兼容结构：
  - 每条消息包含 `role`、`content`、`tool_calls`、`tool_call_id`、`name`、`reasoning` 等字段。
  - `tool_calls` 为数组，元素形如：`{ "id": "...","type": "function","function": { "name": "read","arguments": "{\"path\":\"README.md\"}" } }`。
  - 对应的 `tool` 消息通过 `role="tool"`、`name=<工具名>`、`tool_call_id=<前一条 assistant 的 tool_call.id>` 关联。
- JSON 顶层需要包含 `tools` 字段，记录本会话可用工具定义的快照：
  - 结构直接对齐 OpenAI `tools` 字段：`[{ "type": "function","function": { "name": "...","description": "...","parameters": {...} } }, ...]`。
  - `tools` 作为“当时可用工具集合”的描述，不要求反映运行中工具开关的每一次变更，但必须足以重放一次请求（模型+tools+messages）。
