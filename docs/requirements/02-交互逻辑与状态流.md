# 02. 交互逻辑与状态流

## 1. 单回合主流程
1. 用户输入文本。
2. 系统先判断是否为特殊命令：`!` 或 `/` 前缀。
3. 若为 `!`，进入 shell 命令分支；若为 `/`，进入内建命令分支。
4. 若不是特殊命令，进入模型-工具循环。
5. 模型若返回工具调用，则执行权限检查与工具执行。
6. 没有工具调用时，输出最终答案并结束回合。

## 2. 普通对话模式（非 `!` / `/`）
触发条件：输入不以 `!`、`/` 开头。

关键行为：
- 首先把用户消息追加到会话内存。
- 主聊天时间线需支持纵向滚动，用户可回看历史消息。
- 输入模式为 `plan`、`default`、`auto-edit`、`yolo`：
  - `plan`：以分析、拆解与方案输出为主；默认不走写入链路。
  - `default`：均衡模式；可读可分析，写入行为按用户意图与权限策略触发。
  - `auto-edit`：以改动交付为主；在需求明确时可主动执行写入、验证与修复重试。
  - `yolo`：高自治编辑模式；在 `auto-edit` 基础上对 `bash` 执行默认全放行（含高风险命令）。
- 在每一步模型调用前可能触发上下文压缩。
- 若任务被判定为复杂任务且开启 `require_todo_for_complex`，会自动初始化 todo（仅在当前会话无未完成 todo 时）。
- 模型可连续多步调用工具，直到不再返回 tool calls 或达到步数上限。
- 四种模式共享工作区路径约束；`yolo` 下 `bash` 不再受 `ask`/`deny`/危险命令硬阻断拦截。
- 输入区下方仅保留一行合并状态信息（快捷键/模式/执行状态等），不再拆分多行提示；且该行必须包含当前工作路径（cwd）。
- 顶部不展示独立状态条信息。
- 右侧栏固定展示且仅展示：`Context`、`Model`、`Todos`、`Tools`、`Skills`。

## 3. 命令模式（`!`）
触发条件：输入以 `!` 开头。

行为：
- 跳过模型规划，直接走 `bash` 工具执行路径。
- 非 `yolo` 模式下仍需要经过权限策略与审批检查；`yolo` 模式下走 `bash` 全放行路径。
- 执行结果会以固定结构写回会话文本，包含命令、退出码、stdout/stderr。

## 4. 命令模式（`/`）
触发条件：输入以 `/` 开头。

行为：
- 跳过模型规划，直接进入内建命令分发。
- 首发命令集合：`/help`、`/model`、`/permissions`、`/new`、`/resume`、`/compact`、`/diff`、`/review`、`/undo`。
- 内建命令执行结果以文本回写会话；未知命令返回错误提示。

子命令契约：
- `/help`：展示命令与快捷键说明。
- `/model <name>`：立即切换当前会话模型，并尝试持久化到 `./.coder/config.json`。
- `/permissions [preset]`：无参数时展示当前权限矩阵；有参数时切换权限预设（`strict`、`balanced`、`auto-edit`、`yolo`）。
- `/new`：创建新会话并切到空上下文输入态。
- `/resume <session-id>`：按会话 ID 恢复历史会话；若目标不存在，返回可读错误。
- `/compact`：强制执行一次上下文压缩并回显摘要。
- `/diff`：展示当前工作区改动差异摘要；可展开查看详细 diff。
- `/review`：对当前改动执行代码审查流程并输出问题清单。
- `/undo`：撤销“上一次用户输入对应整回合”产生的文件改动（包含该回合内所有助手写入与补丁，以及该回合新增文件的回收），仅在检测到 git 可用且当前目录是 git 仓库时允许。

会话边界：
- 当前版本仅支持线性会话，不支持 `/fork`。

## 5. 工具执行分支
每个工具调用都会经历：
1. Agent 工具开关检查（工具是否被当前 agent 禁用）。
2. Policy 决策（`allow`/`ask`/`deny`）。
3. 工具自身审批检查（如 bash 危险命令分析）。
4. 执行工具并写入 `tool` 消息。

例外：
- 当前模式为 `yolo` 且工具为 `bash` 时，跳过第 2/3 步，直接执行。

技能触发规则：
- 允许基于语义自动触发 skill（无需用户显式输入技能名）。
- skill 的自动触发路径为免审批执行（即不因 `ask` 弹交互确认）。
- 若技能不存在或加载失败，必须回退到无技能路径并给出可读提示。

工具事件展示规则：
- 默认显示简洁摘要（工具名、关键参数、核心结果、耗时）。
- 用户可在同一条时间线消息中展开查看完整输入参数与完整输出。
- `thinking` 输出支持折叠/展开；默认可折叠以减少主区噪音。

## 6. 自动验证循环
触发条件同时满足：
- 本回合执行过 `write` 或 `patch`。
- 编辑目标不全是文档文件（例如 `.md`、`docs/`）。
- `workflow.auto_verify_after_edit=true`。
- `bash` 工具可用且允许。
- 验证尝试次数未超过 `max_verify_attempts`。
- 当前模式为 `auto-edit` 或 `yolo`；`default` 模式下仅在用户明确要求“执行验证”时触发；`plan` 模式不触发。

行为：
- 自动验证仅允许“最小无副作用检查”白名单命令（固定集合）：
  - `go test ./...`
  - `pytest -q`
  - `npm test -- --watch=false`
  - `pnpm test -- --watch=false`
  - `yarn test --watch=false`
  - `cargo test`
  - `mvn -q test`
  - `gradle test`
  - `./gradlew test`
- 自动选取命令优先级（高到低）：
  1. 用户显式指定且命中白名单的命令。
  2. 项目配置 `workflow.verify_commands` 中首个命中白名单的命令。
  3. 按项目类型推断并映射到白名单中的命令。
- 若候选命令不在白名单内，视为不可执行，不得降级执行其它非白名单命令。
- 若未找到可执行的白名单命令，允许跳过自动验证，但必须显式提示“未执行自动验证”。
- 失败且可重试时，系统向模型注入“请修复并再次验证”的提示继续循环；默认最多自动重试 2 次，可由 `max_verify_attempts` 收紧。
- 失败且不可重试（环境问题）时，给出“best-effort”警告并结束自动验证。

## 7. 复杂任务判定条件
输入先做 `trim`，再按 Unicode 字符计数。满足任一条件即判定为复杂任务：
- 文本长度 `>= 40`。
- 命中多步骤关键词数 `>= 3`（例如：并且、同时、另外、分别、步骤、重构、迁移、优化）。
- 按分隔符 `，。；、,\n` 切分后，有效片段数 `>= 3`。
- 出现显式多目标枚举（如 `1. 2. 3.`、`A/B/C`）。

判定优先级：
1. 先判断显式多目标枚举，命中即复杂任务。
2. 再判断长度阈值 `>= 40`。
3. 再判断关键词与分段阈值（均使用 `>= 3`）。

## 8. 回合终止条件
- 模型返回无工具调用的文本答案。
- 达到步数上限。
- Provider 调用失败并不可恢复。

## 9. `/model` 持久化与继承
- `/model <name>` 在执行成功后立即生效（当前会话）。
- 同步尝试写入 `./.coder/config.json`；写入成功后，后续会话默认继承。
- 若写入失败，不回滚当前会话模型；仅提示持久化失败。
